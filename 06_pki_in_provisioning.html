<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PKI Belongs in Provisioning, Not Runtime</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.8;
            color: #292929;
            background: #fff;
            font-size: 20px;
        }
        .page-wrapper {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 60px;
            padding: 40px 20px;
        }
        .toc-sidebar {
            width: 280px;
            flex-shrink: 0;
        }
        .toc-sticky {
            position: sticky;
            top: 40px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }
        .toc-title {
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #757575;
            margin-bottom: 16px;
        }
        .toc-list {
            list-style: none;
        }
        .toc-item {
            margin-bottom: 8px;
        }
        .toc-link {
            display: block;
            color: #666;
            text-decoration: none;
            font-size: 15px;
            line-height: 1.4;
            padding: 6px 12px;
            border-left: 2px solid transparent;
            transition: all 0.2s;
        }
        .toc-link:hover {
            color: #000;
            border-left-color: #667eea;
            background: #f7f7f7;
        }
        .toc-link.active {
            color: #667eea;
            border-left-color: #667eea;
            background: #f7f7f7;
            font-weight: 600;
        }
        .toc-link.toc-h3 {
            font-size: 14px;
            padding-left: 24px;
            color: #888;
        }
        .toc-link.toc-h3:hover { color: #444; }
        .toc-link.toc-h3.active { color: #667eea; }
        .container {
            max-width: 900px;
            flex: 1;
            min-width: 0;
        }
        .hero-image {
            width: 100%;
            max-width: 1200px;
            height: auto;
            margin: 48px 0;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .series-tag {
            font-size: 14px;
            color: #757575;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        h1 {
            font-size: 42px;
            font-weight: 700;
            line-height: 1.2;
            margin-bottom: 16px;
            color: #000;
        }
        h2 {
            font-size: 32px;
            font-weight: 700;
            margin-top: 56px;
            margin-bottom: 24px;
            color: #000;
        }
        h3 {
            font-size: 24px;
            font-weight: 600;
            margin-top: 40px;
            margin-bottom: 16px;
            color: #000;
        }
        p {
            margin-bottom: 28px;
        }
        .subtitle {
            font-size: 24px;
            color: #757575;
            margin-bottom: 32px;
            line-height: 1.4;
        }
        .callout {
            background: #F7F7F7;
            border-left: 4px solid #000;
            padding: 24px;
            margin: 32px 0;
            border-radius: 4px;
        }
        .callout-danger {
            background: #FFF5F5;
            border-left-color: #E53E3E;
        }
        .callout-success {
            background: #F0FFF4;
            border-left-color: #38A169;
        }
        .callout-warning {
            background: #FFFAF0;
            border-left-color: #DD6B20;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin: 32px 0;
        }
        .comparison-card {
            padding: 24px;
            border-radius: 8px;
            border: 2px solid #E2E8F0;
        }
        .comparison-card.bad {
            border-color: #FC8181;
            background: #FFF5F5;
        }
        .comparison-card.good {
            border-color: #68D391;
            background: #F0FFF4;
        }
        .comparison-card h4 {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 16px;
        }
        .comparison-card ul {
            list-style: none;
            padding-left: 0;
        }
        .comparison-card li {
            padding: 8px 0;
            padding-left: 24px;
            position: relative;
        }
        .comparison-card.bad li:before {
            content: "✗";
            position: absolute;
            left: 0;
            color: #E53E3E;
            font-weight: 700;
        }
        .comparison-card.good li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: #38A169;
            font-weight: 700;
        }
        .key-hierarchy {
            background: #F7FAFC;
            border: 2px solid #E2E8F0;
            border-radius: 8px;
            padding: 32px;
            margin: 32px 0;
        }
        .key-level {
            background: white;
            border-left: 4px solid #4299E1;
            padding: 16px;
            margin: 12px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .key-level-1 { border-left-color: #E53E3E; background: #FFF5F5; }
        .key-level-2 { border-left-color: #DD6B20; background: #FFFAF0; }
        .key-level-3 { border-left-color: #38A169; background: #F0FFF4; }
        .key-level-4 { border-left-color: #4299E1; background: #EBF8FF; }
        .key-name {
            font-family: 'Monaco', monospace;
            font-weight: 700;
            font-size: 14px;
        }
        .key-location {
            font-size: 12px;
            color: #718096;
        }
        .phase-diagram {
            background: #F7FAFC;
            border: 2px solid #E2E8F0;
            border-radius: 8px;
            padding: 24px;
            margin: 32px 0;
        }
        .phase-box {
            background: white;
            border: 2px solid #4299E1;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
        }
        .phase-prov {
            border-color: #DD6B20;
            background: #FFFAF0;
        }
        .phase-runtime {
            border-color: #38A169;
            background: #F0FFF4;
        }
        .phase-title {
            font-weight: 700;
            font-size: 18px;
            margin-bottom: 12px;
        }
        .stat-box {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 32px;
            border-radius: 8px;
            margin: 24px 0;
            font-size: 48px;
            font-weight: 700;
            text-align: center;
            min-width: 200px;
        }
        .stat-label {
            font-size: 16px;
            font-weight: 400;
            margin-top: 8px;
            opacity: 0.9;
        }
        code {
            background: #F7FAFC;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 18px;
            color: #E53E3E;
        }
        pre {
            background: #2D3748;
            color: #E2E8F0;
            padding: 24px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 32px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        .visual-bar {
            height: 60px;
            background: linear-gradient(90deg, #E53E3E 0%, #FC8181 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 18px;
            margin: 16px 0;
        }
        .visual-bar.good {
            background: linear-gradient(90deg, #38A169 0%, #68D391 100%);
        }
        strong {
            font-weight: 700;
            color: #000;
        }
        ul, ol {
            margin-left: 40px;
            margin-bottom: 28px;
        }
        li {
            margin-bottom: 8px;
        }
        @media (max-width: 768px) {
            h1 { font-size: 32px; }
            h2 { font-size: 24px; }
            .comparison { grid-template-columns: 1fr; }
            .page-wrapper { flex-direction: column; gap: 0; padding: 20px; }
            .toc-sidebar { display: none; }
            .container { max-width: 100%; }
        }
    </style>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.querySelector('.container');
            const headings = container.querySelectorAll('h2, h3');
            const tocList = document.getElementById('toc-list');
            headings.forEach((heading, index) => {
                const id = 'section-' + index;
                heading.id = id;
                const li = document.createElement('li');
                li.className = 'toc-item';
                const link = document.createElement('a');
                link.href = '#' + id;
                link.className = 'toc-link toc-' + heading.tagName.toLowerCase();
                link.textContent = heading.textContent;
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    history.pushState(null, null, '#' + id);
                });
                li.appendChild(link);
                tocList.appendChild(li);
            });
            const tocLinks = document.querySelectorAll('.toc-link');
            function highlightTOC() {
                let current = '';
                const scrollPosition = window.scrollY + 100;
                headings.forEach(heading => {
                    if (scrollPosition >= heading.offsetTop) current = heading.id;
                });
                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + current) link.classList.add('active');
                });
            }
            window.addEventListener('scroll', highlightTOC);
            highlightTOC();
        });
    </script>
</head>
<body>
    <div class="page-wrapper">
        <aside class="toc-sidebar">
            <div class="toc-sticky">
                <div class="toc-title">Table of Contents</div>
                <ul id="toc-list" class="toc-list"></ul>
            </div>
        </aside>
        <div class="container">
        <div class="hero">
            <div class="series-tag">Security That Survives Certification • Article 6 of 8</div>
            <h1>PKI Belongs in Provisioning, Not Runtime</h1>
            <div class="subtitle">Why trust establishment happens offline, and authentication happens with symmetric keys</div>
        </div>

        <img src="images/06-hero-pki-provisioning.svg" alt="PKI in Provisioning vs Runtime" class="hero-image">

        <p>Your security architect presents the design: <strong>"We'll use PKI for everything. Certificate-based authentication at runtime, certificate validation, OCSP checks, the whole stack."</strong></p>

        <p>The certification engineer asks: <strong>"Where does PKI live in your architecture?"</strong></p>

        <p>"Everywhere. It's our security foundation."</p>

        <p><strong>That's the architectural mismatch.</strong></p>

        <p>PKI isn't wrong—it's essential for trust establishment. But runtime PKI in safety-critical bounded-trust systems creates the certification challenges we've discussed in Articles 1-5: state explosion, non-deterministic behavior, external dependencies, unbounded timing.</p>

        <p>For bounded-trust aerospace architectures: <strong>PKI excels at provisioning-time trust establishment. Symmetric crypto excels at runtime authentication.</strong></p>

        <div class="callout callout-warning">
            <strong>Architectural Context:</strong> This article addresses bounded-trust safety-critical systems where:
            <ul style="list-style: disc; margin-left: 20px; margin-top: 12px; margin-bottom: 0;">
                <li>Trust relationships are pre-established (aircraft ↔ ground tool)</li>
                <li>Provisioning cycles align with maintenance schedules</li>
                <li>DO-178C/DO-326A certification is required</li>
                <li>Deterministic runtime behavior is mandatory</li>
            </ul>
            <p style="margin-top: 12px; margin-bottom: 0;">Runtime PKI may be appropriate in other contexts (large-scale IoT, dynamic trust, non-safety-critical systems).</p>
        </div>

        <h2>The Two-Phase Architecture</h2>

        <p>Safety-critical systems need <strong>two distinct security phases</strong> with different requirements:</p>

        <div class="comparison">
            <div class="comparison-card bad">
                <h4>Provisioning Phase</h4>
                <ul>
                    <li>Controlled environment (factory/MRO)</li>
                    <li>Time constraints relaxed (minutes to hours acceptable)</li>
                    <li>Human oversight required</li>
                    <li>External dependencies OK</li>
                    <li>Complex operations acceptable</li>
                    <li><strong>PKI lives here</strong></li>
                </ul>
            </div>
            <div class="comparison-card good">
                <h4>Runtime Phase</h4>
                <ul>
                    <li>Operational environment (field)</li>
                    <li>Bounded time (≤15s auth)</li>
                    <li>Autonomous operation</li>
                    <li>No external dependencies</li>
                    <li>Deterministic behavior required</li>
                    <li><strong>Symmetric crypto for authentication</strong></li>
                </ul>
            </div>
        </div>

        <p><strong>Key principle:</strong> Use PKI to <strong>establish trust</strong> during provisioning. Use symmetric crypto to <strong>authenticate</strong> at runtime.</p>

        <h2>Why Runtime PKI Creates Certification Challenges</h2>

        <p>We've covered this across articles 1-5, but let's consolidate:</p>

        <h3>State Machine Complexity (Article 1)</h3>
        <ul>
            <li>TLS handshake: ~75+ states (varies by implementation and TLS version)</li>
            <li>Certificate validation: chains, extensions, policies</li>
            <li>Certification effort: Order of magnitude 100-200 person-weeks (DAL B TLS + certificate validation stack)</li>
        </ul>

        <h3>Protocol Mismatch (Article 2)</h3>
        <ul>
            <li>TLS assumes TCP streams</li>
            <li>Embedded uses message buses (CAN, ARINC 429)</li>
            <li>Fragmentation adds significant state complexity (scales with fragment count)</li>
        </ul>

        <h3>Revocation Dependencies (Article 3)</h3>
        <ul>
            <li>OCSP requires network connectivity</li>
            <li>Hard-fail = operational disruption</li>
            <li>Soft-fail = security violation</li>
        </ul>

        <h3>Non-Determinism (Articles 4 & 5)</h3>
        <ul>
            <li>Variable handshake timing (2-30s)</li>
            <li>Ambiguous failure modes</li>
            <li>No WCET guarantee</li>
        </ul>

        <div class="callout callout-danger">
            <strong>Runtime PKI creates certification challenges:</strong>
            <ul style="list-style: disc; margin-left: 20px; margin-top: 12px; margin-bottom: 0;">
                <li>High state complexity (~75+ protocol states, additional fragmentation)</li>
                <li>External dependencies (OCSP, time sync)</li>
                <li>Non-deterministic timing (multi-second range, network-dependent)</li>
                <li>Operational fragility (hard-fail/soft-fail dilemma)</li>
                <li>High certification burden (order of magnitude 100-200 person-weeks for DAL B)</li>
            </ul>
        </div>

        <h2>The Key Hierarchy</h2>

        <p>Instead of runtime PKI, use <strong>hierarchical key derivation</strong> established during provisioning.</p>

        <div class="key-hierarchy">
            <div style="font-weight: 700; margin-bottom: 16px;">4-Level Key Hierarchy</div>
            
            <div class="key-level key-level-1">
                <div>
                    <div class="key-name">Root CA Key (K_Root)</div>
                    <div class="key-location">Air-gapped HSM, offline vault</div>
                </div>
                <div style="color: #E53E3E; font-weight: 700;">Level 1</div>
            </div>
            
            <div class="key-level key-level-2">
                <div>
                    <div class="key-name">Device Identity Keys (K_Aircraft, K_Ground)</div>
                    <div class="key-location">TPM/SE, injected at manufacturing</div>
                </div>
                <div style="color: #DD6B20; font-weight: 700;">Level 2</div>
            </div>
            
            <div class="key-level key-level-3">
                <div>
                    <div class="key-name">Pairwise Authorization Key (K_AG)</div>
                    <div class="key-location">TPM/SE, derived at provisioning</div>
                </div>
                <div style="color: #38A169; font-weight: 700;">Level 3</div>
            </div>
            
            <div class="key-level key-level-4">
                <div>
                    <div class="key-name">Session Keys (K_Session)</div>
                    <div class="key-location">RAM, derived at runtime from nonces</div>
                </div>
                <div style="color: #4299E1; font-weight: 700;">Level 4</div>
            </div>
        </div>

        <h3>Level 1: Root CA Key</h3>

        <p><strong>Purpose:</strong> Signs device certificates, issues intermediate CAs</p>

        <p><strong>Storage:</strong> Air-gapped HSM in secure facility</p>

        <p><strong>Usage:</strong> Extremely rare (device manufacturing, intermediate CA creation)</p>

        <p><strong>Lifetime:</strong> 20+ years</p>

        <pre>// Root CA usage (factory only, never at runtime)
class RootCA {
    private_key: K_Root  // In HSM, never exported
    
    issue_device_certificate(device_id, public_key) {
        // This happens at manufacturing, not runtime
        cert = Certificate {
            subject: f"CN=Aircraft-{device_id}",
            public_key: public_key,
            issuer: "CN=Root CA",
            not_before: utc_now(),
            not_after: utc_now() + years(10),
            extensions: {
                key_usage: [digitalSignature, keyEncipherment],
                basic_constraints: {ca: false},
            }
        }
        
        // Sign with Root CA private key (in HSM)
        signature = hsm.sign(K_Root, cert.tbs_certificate)
        cert.signature = signature
        
        return cert
    }
}</pre>

        <h3>Level 2: Device Identity Keys</h3>

        <p><strong>Purpose:</strong> Prove device identity, derive pairwise keys</p>

        <p><strong>Storage:</strong> TPM (aircraft), SE (ground tool)</p>

        <p><strong>Usage:</strong> Provisioning only (not runtime authentication)</p>

        <p><strong>Lifetime:</strong> 10 years (aircraft service life)</p>

        <pre>// Device identity usage (provisioning only)
class DeviceIdentity {
    device_id: String
    private_key: K_Device  // In TPM, non-exportable
    certificate: X509Certificate
    
    derive_pairwise_key(peer_device_id) {
        // Provisioning phase: derive K_AG from device identities
        // HKDF(Root_Secret, Aircraft_ID || Ground_ID, "authorization")
        
        // Both devices must be present
        // Technician authenticates with master provisioning tool
        // K_AG injected into both TPMs
        
        k_ag = hkdf_sha256(
            ikm: root_secret,
            salt: this.device_id || peer_device_id,
            info: b"pairwise-authorization"
        )
        
        // Store in TPM
        tpm.store_key(f"K_AG_{peer_device_id}", k_ag)
        
        // Log in audit trail
        audit_log.record({
            event: "PAIRWISE_KEY_PROVISIONED",
            device_a: this.device_id,
            device_b: peer_device_id,
            key_id: f"K_AG_{peer_device_id}",
            technician: current_user(),
            timestamp: utc_now()
        })
    }
}</pre>

        <h3>Level 3: Pairwise Authorization Keys</h3>

        <p><strong>Purpose:</strong> Runtime authentication between specific device pairs</p>

        <p><strong>Storage:</strong> TPM/SE (non-exportable)</p>

        <p><strong>Usage:</strong> Runtime authentication (HMAC challenge-response)</p>

        <p><strong>Lifetime:</strong> 1-5 years (MRO rotation)</p>

        <p><strong>Key property:</strong> Aircraft A has K_AG for Ground Tool G. Ground Tool G has K_AG for Aircraft A. <strong>Same key, provisioned to both.</strong></p>

        <h3>Level 4: Session Keys</h3>

        <p><strong>Purpose:</strong> Encrypt/authenticate data during single maintenance session</p>

        <p><strong>Storage:</strong> RAM only (volatile)</p>

        <p><strong>Usage:</strong> Derived at start of each session from nonces</p>

        <p><strong>Lifetime:</strong> Single session (minutes to hours)</p>

        <pre>// Session key derivation (runtime)
class RuntimeAuthenticator {
    k_ag: [u8; 32]  // From TPM
    
    authenticate_and_derive_session() {
        // Step 1: Challenge-response (proves both have K_AG)
        nonce_g = random_bytes(16)
        nonce_a = random_bytes(16)
        
        hmac_a = hmac_sha256(this.k_ag, nonce_g || nonce_a)
        hmac_g = hmac_sha256(this.k_ag, nonce_a || nonce_g)
        
        // Verify HMACs (mutual authentication)
        // ...
        
        // Step 2: Derive session key
        k_session = hkdf_sha256(
            ikm: this.k_ag,
            salt: nonce_g || nonce_a,
            info: b"session-2024-11-06",
            length: 32
        )
        
        // Store in RAM (volatile)
        this.session_key = k_session
        
        // Use for data protection
        return k_session
    }
}</pre>

        <h2>The Provisioning Phase</h2>

        <p>This is <strong>where PKI lives.</strong> Controlled environment, unlimited time, human oversight.</p>

        <h3>Factory Provisioning (Initial)</h3>

        <div class="phase-diagram">
            <div class="phase-box phase-prov">
                <div class="phase-title">Factory: Aircraft Manufacturing</div>
                <ol style="margin: 12px 0 0 20px;">
                    <li>Generate K_Aircraft keypair in aircraft TPM</li>
                    <li>Export public key, send to Root CA (offline)</li>
                    <li>Root CA issues certificate (X.509, 10-year validity)</li>
                    <li>Certificate loaded into aircraft secure storage</li>
                    <li>K_Aircraft private key stays in TPM (non-exportable)</li>
                    <li><strong>Time: 1-2 hours (acceptable, one-time)</strong></li>
                </ol>
            </div>
            
            <div class="phase-box phase-prov">
                <div class="phase-title">Factory: Ground Tool Manufacturing</div>
                <ol style="margin: 12px 0 0 20px;">
                    <li>Generate K_Ground keypair in tool SE</li>
                    <li>Export public key, send to Root CA</li>
                    <li>Root CA issues certificate (10-year validity)</li>
                    <li>Certificate loaded into tool secure storage</li>
                    <li>K_Ground private key stays in SE</li>
                    <li><strong>Time: 1-2 hours</strong></li>
                </ol>
            </div>
        </div>

        <h3>MRO Provisioning (Authorization)</h3>

        <p>When Aircraft A needs to be serviced by Ground Tool G:</p>

        <div class="phase-diagram">
            <div class="phase-box phase-prov">
                <div class="phase-title">MRO: Pairwise Key Provisioning</div>
                <ol style="margin: 12px 0 0 20px;">
                    <li>Technician connects master provisioning tool</li>
                    <li>Authenticates with admin credentials</li>
                    <li>Verifies aircraft cert (signed by Root CA)</li>
                    <li>Verifies ground tool cert (signed by Root CA)</li>
                    <li>Derives K_AG = HKDF(Root, Aircraft_SN || Ground_ID)</li>
                    <li>Injects K_AG into aircraft TPM</li>
                    <li>Injects K_AG into ground tool SE</li>
                    <li>Records in audit log (who, when, which devices)</li>
                    <li><strong>Time: 5-10 minutes (acceptable, infrequent)</strong></li>
                </ol>
            </div>
        </div>

        <p><strong>Key insight:</strong> PKI is used here to verify device identities. But the <strong>runtime key (K_AG) is symmetric,</strong> derived and injected offline.</p>

        <h3>Implementation: Provisioning Tool</h3>

        <pre>// Master provisioning tool (MRO facility)
class ProvisioningTool {
    root_secret: [u8; 32]  // From HSM, auth required
    
    provision_pairwise_authorization(aircraft_sn, ground_tool_id) {
        // Step 1: Verify devices using PKI
        aircraft_cert = aircraft.get_certificate()
        ground_cert = ground_tool.get_certificate()
        
        if not verify_certificate(aircraft_cert, root_ca):
            return Error("Aircraft cert invalid")
        
        if not verify_certificate(ground_cert, root_ca):
            return Error("Ground tool cert invalid")
        
        // Step 2: Derive pairwise key
        k_ag = hkdf_sha256(
            ikm: this.root_secret,
            salt: aircraft_sn.bytes() || ground_tool_id.bytes(),
            info: b"pairwise-authorization-v1",
            length: 32
        )
        
        // Step 3: Inject into aircraft TPM
        aircraft_result = aircraft.tpm.inject_key(
            key_id: f"K_AG_{ground_tool_id}",
            key_material: k_ag,
            usage: [HMAC, HKDF],
            exportable: false
        )
        
        // Step 4: Inject into ground tool SE
        ground_result = ground_tool.se.inject_key(
            key_id: f"K_AG_{aircraft_sn}",
            key_material: k_ag,
            usage: [HMAC, HKDF],
            exportable: false
        )
        
        // Step 5: Audit logging
        audit_log.record({
            event: "PAIRWISE_PROVISIONING",
            aircraft: aircraft_sn,
            ground_tool: ground_tool_id,
            key_id: f"K_AG_{aircraft_sn}_{ground_tool_id}",
            technician: current_user(),
            facility: current_facility(),
            timestamp: utc_now(),
            aircraft_tpm_slot: aircraft_result.slot_id,
            ground_se_slot: ground_result.slot_id
        })
        
        // Step 6: Zero sensitive material
        secure_zero(k_ag)
        
        return Success({
            aircraft: aircraft_sn,
            ground_tool: ground_tool_id,
            provisioned_at: utc_now()
        })
    }
}</pre>

        <h2>The Runtime Phase</h2>

        <p>This is <strong>where symmetric crypto lives.</strong> Deterministic, bounded, no external dependencies.</p>

        <h3>Runtime Authentication</h3>

        <p><strong>No PKI.</strong> Just HMAC challenge-response using the pre-provisioned K_AG.</p>

        <pre>// Runtime authentication (symmetric only)
class RuntimeAuth {
    k_ag: [u8; 32]  // From TPM, provisioned earlier
    
    authenticate() -> Result<SessionKey, AuthError> {
        start = time.monotonic()
        
        // Step 1: Ground sends challenge (1ms)
        nonce_g = random_bytes(16)
        send(nonce_g)
        
        // Step 2: Aircraft responds with its nonce (1ms)
        nonce_a = receive_with_timeout(timeout_ms: 2000)
            .ok_or(AuthError::TIMEOUT_NONCE)?
        
        // Step 3: Aircraft sends HMAC proof (1ms)
        hmac_a = receive_with_timeout(timeout_ms: 2000)
            .ok_or(AuthError::TIMEOUT_HMAC)?
        
        // Step 4: Verify aircraft HMAC (0.5ms)
        expected_hmac_a = hmac_sha256(
            this.k_ag,
            nonce_g || nonce_a
        )
        
        if not constant_time_compare(hmac_a, expected_hmac_a):
            return Err(AuthError::HMAC_INVALID)
        
        // Step 5: Send ground HMAC proof (1ms)
        hmac_g = hmac_sha256(this.k_ag, nonce_a || nonce_g)
        send(hmac_g)
        
        // Step 6: Derive session key (1ms)
        k_session = hkdf_sha256(
            ikm: this.k_ag,
            salt: nonce_g || nonce_a,
            info: b"session",
            length: 32
        )
        
        elapsed = time.monotonic() - start
        assert elapsed < 3.0  // WCET guarantee
        
        return Ok(SessionKey {
            key: k_session,
            nonce_g: nonce_g,
            nonce_a: nonce_a,
            established_at: utc_now()
        })
    }
}

// WCET: <3 seconds
// States: 5 (vs 76+ for TLS)
// Dependencies: None (vs OCSP, time sync for PKI)</pre>

        <h2>Key Rotation at MRO</h2>

        <p>Pairwise keys (K_AG) should be rotated periodically. <strong>This happens during scheduled maintenance,</strong> not at runtime.</p>

        <h3>Rotation Procedure</h3>

        <div class="phase-diagram">
            <div class="phase-box phase-prov">
                <div class="phase-title">MRO: Key Rotation (Annual)</div>
                <ol style="margin: 12px 0 0 20px;">
                    <li>Aircraft in maintenance hangar (scheduled)</li>
                    <li>Technician connects provisioning tool</li>
                    <li>Lists current authorizations: K_AG for tools G1, G2, G3</li>
                    <li>For each authorized tool:</li>
                    <ul style="margin: 8px 0 8px 20px;">
                        <li>Delete old K_AG from aircraft TPM</li>
                        <li>Derive new K_AG' (with updated salt/version)</li>
                        <li>Inject new K_AG' into aircraft TPM</li>
                        <li>Update tool SE with new K_AG' (tool must be present)</li>
                    </ul>
                    <li>Record rotation in audit log</li>
                    <li><strong>Time: 15-20 minutes for 10 tools</strong></li>
                </ol>
            </div>
        </div>

        <p><strong>Key rotation is procedural,</strong> not runtime. No OCSP. No CRL. Just delete old key, inject new key.</p>

        <h3>Implementation</h3>

        <pre>// Key rotation (MRO procedure)
class KeyRotation {
    rotate_pairwise_key(aircraft_sn, ground_tool_id) {
        // Step 1: Delete old key
        aircraft.tpm.delete_key(f"K_AG_{ground_tool_id}")
        ground_tool.se.delete_key(f"K_AG_{aircraft_sn}")
        
        // Step 2: Derive new key (with version)
        k_ag_new = hkdf_sha256(
            ikm: root_secret,
            salt: aircraft_sn || ground_tool_id || version_counter,
            info: b"pairwise-authorization-v2",  // Updated version
            length: 32
        )
        
        // Step 3: Inject new key
        aircraft.tpm.inject_key(f"K_AG_{ground_tool_id}", k_ag_new)
        ground_tool.se.inject_key(f"K_AG_{aircraft_sn}", k_ag_new)
        
        // Step 4: Audit
        audit_log.record({
            event: "KEY_ROTATION",
            aircraft: aircraft_sn,
            ground_tool: ground_tool_id,
            old_version: version_counter - 1,
            new_version: version_counter,
            technician: current_user(),
            timestamp: utc_now()
        })
        
        // Step 5: Verify new key works
        test_result = perform_test_authentication(aircraft, ground_tool)
        if not test_result.success:
            rollback_rotation()
            return Error("Rotation verification failed")
        
        return Success()
    }
}</pre>

        <h2>Comparison: Runtime PKI vs Provisioning PKI</h2>

        <div style="margin: 48px 0;">
            <p style="font-size: 14px; color: #718096; margin-bottom: 8px;">PKI at Runtime (Every Auth)</p>
            <div class="visual-bar" style="width: 100%;">
                ~75 states | Multi-second timing | OCSP dependency | Certification-expensive
            </div>
        </div>

        <div style="margin: 48px 0;">
            <p style="font-size: 14px; color: #718096; margin-bottom: 8px;">PKI in Provisioning + Symmetric Runtime</p>
            <div class="visual-bar good" style="width: 5%; min-width: 8px;">&nbsp;</div>
            <p style="font-size: 16px; color: #38A169; font-weight: 600; margin-top: 8px; margin-bottom: 0;">
                5 states &nbsp;|&nbsp; <3s bounded &nbsp;|&nbsp; No dependencies &nbsp;|&nbsp; Certifiable
            </p>
        </div>

        <div class="callout callout-success">
            <strong>Provisioning PKI + Symmetric Runtime:</strong>
            <ul style="list-style: disc; margin-left: 20px; margin-top: 12px; margin-bottom: 0;">
                <li>PKI used for trust establishment (offline, controlled)</li>
                <li>Symmetric keys derived and injected (TPM/SE)</li>
                <li>Runtime uses HMAC only (5 states, <3s, deterministic)</li>
                <li>Key rotation procedural (MRO, not runtime)</li>
                <li>No OCSP, no CRL, no external dependencies</li>
                <li>Certifiable (DO-178C/DO-326A compliant)</li>
            </ul>
        </div>

        <h2>When Runtime PKI Makes Sense</h2>

        <p>To be clear: runtime PKI works in specific contexts.</p>

        <p><strong>Use runtime PKI when:</strong></p>
        <ol>
            <li><strong>Dynamic trust required:</strong> Unknown parties, no pre-provisioning</li>
            <li><strong>Scale exceeds provisioning:</strong> Millions of devices, can't provision pairwise</li>
            <li><strong>No certification:</strong> Commercial systems, not safety-critical</li>
            <li><strong>Network reliable:</strong> Always-on connectivity for OCSP/CRL</li>
            <li><strong>Non-deterministic OK:</strong> Variable timing acceptable</li>
        </ol>

        <p><strong>Don't use runtime PKI when:</strong></p>
        <ol>
            <li><strong>Pre-established relationships:</strong> Aircraft ↔ ground tool (known pairs)</li>
            <li><strong>Controlled provisioning:</strong> Factory/MRO have access to both devices</li>
            <li><strong>Certification required:</strong> DO-178C, DO-326A, ISO 26262</li>
            <li><strong>Deterministic required:</strong> Bounded WCET, explicit failures</li>
            <li><strong>Offline operation:</strong> Remote locations, no connectivity</li>
        </ol>

        <div class="callout callout-warning">
            <strong>Hybrid Approaches:</strong> Some architectures successfully use asymmetric crypto at boot/setup (e.g., DTLS session establishment over ISO-TP) with symmetric operations at runtime. This can work when:
            <ul style="list-style: disc; margin-left: 20px; margin-top: 12px; margin-bottom: 0;">
                <li>Boot-time operations are off the real-time path</li>
                <li>Session lifetime covers operational window</li>
                <li>Certification burden is accepted for setup phase</li>
            </ul>
        </div>

        <h2>Conclusion: Separate Concerns</h2>

        <p>The title is "PKI Belongs in Provisioning, Not Runtime."</p>

        <p>More precisely: In safety-critical bounded-trust aerospace systems, PKI and runtime authentication have fundamentally different operational requirements. Separating them by phase—PKI for trust establishment during provisioning, symmetric crypto for authentication at runtime—resolves the certification and operational challenges that emerge when these concerns are conflated.</p>

        <p><strong>Provisioning:</strong></p>
        <ul>
            <li>Controlled environment (factory, MRO hangar)</li>
            <li>Time constraints relaxed (minutes to hours acceptable)</li>
            <li>Human oversight (technician present)</li>
            <li>Complex operations OK (certificate validation, chain building)</li>
            <li><strong>PKI excels here</strong></li>
        </ul>

        <p><strong>Runtime:</strong></p>
        <ul>
            <li>Field operation (remote maintenance facility, 2 AM)</li>
            <li>Bounded time (≤15s for ground ops)</li>
            <li>Autonomous (no human intervention)</li>
            <li>Deterministic required (certification mandates)</li>
            <li><strong>Symmetric crypto excels here</strong></li>
        </ul>

        <div class="callout callout-warning">
            <strong>Use PKI for what it's good at: establishing trust.</strong><br><br>
            Factory: Generate device certificates<br>
            MRO: Verify identities, derive pairwise keys<br>
            Audit: Trace key lineage to Root CA<br><br>
            <strong>Use symmetric crypto for what it's good at: runtime authentication.</strong><br><br>
            Operations: HMAC challenge-response<br>
            Data protection: AES-GCM with session keys<br>
            Deterministic: 5 states, <3s WCET, no dependencies
        </div>

        <p><strong>Design security architecture with phase separation from day one.</strong></p>

        <div style="margin-top: 64px; padding-top: 32px; border-top: 2px solid #E2E8F0;">
            <p style="font-size: 16px; color: #718096;"><strong>Next in series:</strong> Article 7 - Security Teams That Don't Break Programs<br>
            How to integrate security into embedded development without becoming a blocker. Purple Team methodology, closed-loop feedback, and metrics that actually matter.</p>

            <p style="font-size: 14px; color: #718096; margin-top: 24px;"><em>About this series: Security That Survives Certification is an 8-part series on building cybersecurity architectures that work in safety-critical embedded systems. Target audience: Staff/Principal Engineers, Security Architects, DERs, Technical CISOs working in avionics, automotive, medical devices, and other safety-critical domains.</em></p>
        </div>
        </div><!-- /.container -->
    </div><!-- /.page-wrapper -->
</body>
</html>
